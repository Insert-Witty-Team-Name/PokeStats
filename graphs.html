<!DOCTYPE html>
<style>
    body {
        margin: 0;
        display: flex;
        width: 1000px;
        padding: 100px;
    }
    .selections {
        padding-left: 20px;
    }
    strong {
        display: flex;
        width: 130px;
        justify-content: space-between;
    }
</style>
<html>
    <head>
        <!-- <link rel="stylesheet" href="exploration.css"> -->
        <title>Pok√©Stats</title>
    </head>
    <body>
        <div id="graphs"></div>
        <div class="selections">
            <div>
                <strong>x: <select id="stat1" class="dropdown"></select></strong><br>
                <strong>y: <select id="stat2" class="dropdown"></select></strong><br>
            </div>
            <form id="types"></form>
        </div>
        
    </body>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        async function ready() {
            const data = await d3.csv("/pokedex.csv", function(d) {
                // console.log(d)
                dict[d.name] = {
                    "HP": parseInt(d.hp),
                    "Attack": parseInt(d.attack),
                    "Defense": parseInt(d.defense),
                    "Sp_Attack": parseInt(d.sp_attack),
                    "Sp_Defense": parseInt(d.sp_defense),
                    "Speed": parseInt(d.speed),
                    "types": d.type_number == 2 ? [d.type_1, d.type_2] : [d.type_1],
                    "legendary": d.status
                }
                
                stats_list_dict['HP'].push(parseInt(d.hp))
                stats_list_dict['Attack'].push(parseInt(d.attack))
                stats_list_dict['Defense'].push(parseInt(d.defense))
                stats_list_dict['Sp_Attack'].push(parseInt(d.sp_attack))
                stats_list_dict['Sp_Defense'].push(parseInt(d.sp_defense))
                stats_list_dict['Speed'].push(parseInt(d.speed))

            })
            
            await drawLines()

            // console.log(data)
            // console.log(Object.keys(dict))
        }


        var margin = { top: 70, right: 10, bottom: 20, left: 100 };
        var width = 1280 - margin.left - margin.right;
        var height = 750 - margin.top - margin.bottom;

        var scatter_svg = d3.select("#graphs").append("svg")
            .style("width", '1280px')
            .style("height", '750')
            .style("outline", '3px solid black')
            .attr("class", "graph")
            .attr("id", "scatter_svg")
            .append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var dict = {};
        var x_axis = "Attack";
        var y_axis = "Sp_Attack";
        var curr_types = [];

        var stat_options1 = ["Attack", "HP", "Defense", "Sp_Attack", "Sp_Defense", "Speed"]
        var stat_options2 = ["Sp_Attack", "Attack", "HP", "Defense", "Sp_Defense", "Speed"]
        var type_options = ["Normal", "Fire", "Water", "Grass", "Electric", "Ice", "Fighting", "Poison", "Ground", "Flying", "Psychic", "Bug", "Rock", "Ghost", "Dark", "Dragon", "Steel", "Fairy"]

        d3.select("#stat1")
            .selectAll("myOptions")
                .data(stat_options1)
            .enter().append('option')
            .text(d => d)
            .attr("value", d => d);
        d3.select("#stat2")
            .selectAll("myOptions")
                .data(stat_options2)
            .enter().append('option')
            .text(d => d)
            .attr("value", d => d);

        d3.select("#stat1").on("change", function(d) {
            x_axis = d3.select(this).property("value");
            Draw();
        })
        d3.select("#stat2").on("change", function(d) {
            y_axis = d3.select(this).property("value");
            Draw();
        })

        type_options.forEach((val) => {
            document.querySelector("#types").innerHTML +=`
            <input type="checkbox" id=${val} name=${val} value=${val} class="type" onchange="Draw()">
            <label for=${val}>${val}</label><br>`
        })

        function Draw() {
            //var filtered_dict = dict.filter(key => curr_types.includes(dict[key].types[0]) || (dict[key].types.length == 2 ? curr_types.includes(dict[key].types[1]) : false))
            curr_types = []
            document.querySelectorAll(".type").forEach((val) => {
                if (val.checked) {
                    curr_types.push(val.value)
                }
            })
            var filtered_dict = Object.keys(dict).reduce(function (filtered_dict, key) {
                if (curr_types.includes(dict[key].types[0]) || (dict[key].types.length == 2 ? curr_types.includes(dict[key].types[1]) : false)) {
                // if (curr_types.includes(dict[key].types[0])) {
                    filtered_dict[key] = {
                        "x": dict[key][x_axis],
                        "y": dict[key][y_axis],
                        "types": dict[key]["types"],
                        "legendary": dict[key]["legendary"]
                    };
                }
                return filtered_dict
            }, {})
            console.log(filtered_dict)
            var xScale = d3.scaleLinear()
                .domain(d3.extent(Object.keys(filtered_dict), key => filtered_dict[key].x))
                .range([0, 1000]);
            var yScale = d3.scaleLinear()
                .domain(d3.extent(Object.keys(filtered_dict), key => filtered_dict[key].y))
                .range([600, 0]);
            
            var xAxis = d3.axisBottom()
                .scale(xScale);
            var yAxis = d3.axisLeft()
                .scale(yScale);
            if (scatter_svg.selectAll("#xaxis").size() == 0){
                scatter_svg.append("g")
                    .call(xAxis)
                    .attr("transform", "translate(0, 600)")
                    .attr("id", "xaxis");
                scatter_svg.append("g")
                    .call(yAxis)
                    .attr("id", "yaxis");

                scatter_svg.append("text")
                    .attr("text-anchor", "middle")
                    .attr("x", (width - margin.left - margin.right) / 2)
                    .attr("y", height)
                    .attr("font-size", 30)
                    .attr("id", "xtext")
                    .text(x_axis)  
                
                scatter_svg.append("text")
                    .attr("text-anchor", "middle")
                    .attr("x", -(height - margin.top - margin.bottom) / 2)
                    .attr("y", -50)
                    .attr("font-size", 30)
                    .attr("id", "ytext")
                    .attr("transform", "rotate(-90)")
                    .text(y_axis)
            } else {
                scatter_svg.select("#xaxis")
                    .transition()
                        .duration(300)
                        .call(xAxis);
                scatter_svg.select("#yaxis")
                    .transition()
                        .duration(300)
                        .call(yAxis);
                scatter_svg.select("#xtext")
                    .text(x_axis)
                scatter_svg.select("#ytext")
                    .text(y_axis)
            }
        
            scatter_svg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", (width - margin.left - margin.right) / 2)
                .attr("y", -margin.top/3)
                .attr("font-size", 40)
                // .text(`${x_axis}vs ${y_axis}`)               // GET TITLE TO UPDATE!!!
                .text("Attack vs Sp Attack")

            function getColor(type) {
                switch (type) {
                    case "Normal": 
                        return "#A8A77A";
                    case "Fire": 
                        return "#EE8130";
                    case "Water": 
                        return "#6390F0";
                    case "Electric": 
                        return "#F7D02C";
                    case "Grass": 
                        return "#7AC74C";
                    case "Ice": 
                        return "#96D9D6";
                    case "Fighting": 
                        return "#C22E28";
                    case "Poison": 
                        return "#A33EA1";
                    case "Ground": 
                        return "#E2BF65";
                    case "Flying": 
                        return "#A98FF3";
                    case "Psychic": 
                        return "#F95587";
                    case "Bug": 
                        return "#A6B91A";
                    case "Rock": 
                        return "#B6A136";
                    case "Ghost": 
                        return "#735797";
                    case "Dragon": 
                        return "#6F35FC";
                    case "Dark": 
                        return "#705746";
                    case "Steel": 
                        return "#B7B7CE";
                    case "Fairy": 
                        return "#D685AD";
                    default:
                        console.log("something wrong with types")
                }
            }

            var selection = scatter_svg.selectAll("circle")
                .data(Object.keys(filtered_dict))
                                
            selection.enter().append("circle")
                .attr("cx", key => xScale(filtered_dict[key].x))
                .attr("cy", key => yScale(filtered_dict[key].y))
                .attr("r", 5)
                .attr("fill", key => getColor(filtered_dict[key].types[0]))
                .on('mouseover', key => console.log(key))

            // Jacob: from my understanding, selection.transition() is equivalent to selection.join(update)
            selection.transition()
                .duration(500)
                .attr("cx", key => xScale(filtered_dict[key].x))
                .attr("cy", key => yScale(filtered_dict[key].y))
                .attr("r", 5)
                .attr("fill", key => getColor(filtered_dict[key].types[0]))
                // 
                
                
            selection.exit().remove()
                
            
                    
                    // .on('mouseover', function(d, i) {

                    //     scatter_svg.append("text")
                    //         .attr("x", d.target.cx.baseVal.value)
                    //         .attr("y", d.target.cy.baseVal.value - 10)
                    //         .attr("text-anchor", "middle")
                    //         .attr("text-size", 10)
                    //         .style("background", "black")
                    //         .text(i);

                    // })
                    // .on('mouseout', function() {
                    //     scatter_svg.select("#name").remove();
                    // })
        }


        // let HP = []
        // let Attack = []
        // let Defense = []
        // let Sp_Attack = []
        // let Sp_Defense = []
        // let Speed = []
        let stats_list_dict = { // needed to set the bounds of parallel axes
            "HP": [],
            "Attack": [],
            "Defense": [],
            "Sp_Attack": [],
            "Sp_Defense": [],
            "Speed": []
        }

        // loading pokemon stat data into dict
        // d3.csv("/pokedex.csv", function(d) {
        //     // console.log(d)
        //     dict[d.name] = {
        //         "HP": parseInt(d.hp),
        //         "Attack": parseInt(d.attack),
        //         "Defense": parseInt(d.defense),
        //         "Sp_Attack": parseInt(d.sp_attack),
        //         "Sp_Defense": parseInt(d.sp_defense),
        //         "Speed": parseInt(d.speed),
        //         "types": d.type_number == 2 ? [d.type_1, d.type_2] : [d.type_1],
        //         "legendary": d.status
        //     }
            
        //     stats_list_dict['HP'].push(parseInt(d.hp))
        //     stats_list_dict['Attack'].push(parseInt(d.attack))
        //     stats_list_dict['Defense'].push(parseInt(d.defense))
        //     stats_list_dict['Sp_Attack'].push(parseInt(d.sp_attack))
        //     stats_list_dict['Sp_Defense'].push(parseInt(d.sp_defense))
        //     stats_list_dict['Speed'].push(parseInt(d.speed))

        //     data = d
        // })
        // console.log(data)
        // console.log(dict)
        // console.log(stats_list_dict)
        // console.log(Object.keys(dict))
        // var count = 0
        // for (let key in Object.keys(dict)) {
        //     console.log(count)
        //     console.log(key)
        //     console.log(dict[key]["HP"])
        //     count += 1
        // }
        // console.log(stats_list['HP'])

        // Initializing Axes for Parallel Coordinates
        let parallel_yScale = {}
        for(i in Object.keys(stats_list_dict)) {
            stat_name = Object.keys(stats_list_dict)[i]
            parallel_yScale[stat_name] = d3.scaleLinear()
                .domain(d3.extent(stats_list_dict[stat_name]))
                .range([height, 0])
            // parallel_yAxis[stat_name] = d3.axisLeft().scale(y_scale)
        }

        let parallel_xScale = d3.scalePoint()
            .domain(Object.keys(stats_list_dict))    
            .range([0, width-margin.left])
            // .padding(10)
                 
        // Adding new svg for Parallel Coordinates
        let parallel_svg = d3.select("#graphs").append("svg")
            .style("width", '1280px')
            .style("height", '750')
            .style("outline", '3px solid black')
            .attr("class", "graph")
            .attr("id", "parallel_svg")
            .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // Add axes
        parallel_svg.selectAll("myAxis")
            .data(Object.keys(stats_list_dict))
            .enter()
            .append("g")
            .attr("class", "yAxis")
            .attr("transform", function(d) { return "translate(" + parallel_xScale(d) + ")"; })
            .each(function(d) { d3.select(this).call(d3.axisLeft().scale(parallel_yScale[d])) })
            .append("text")
                .style("text-anchor", "middle")
                .attr("y", -margin.top/2)
                .text(function(d) { return d; })
                .style("fill", "black")
                .attr("font-size", 25)
        
        // function path(d) {
        //     const result_path = d3.line()(Object.keys(stats_list_dict).map(p => {
        //         return [parallel_xScale(p), parallel_yScale[p](d[p])]
        //     }))

        //     return result_path
        // }


        function drawLines() {
                function path(d) {
                    const result_path = d3.line()(Object.keys(stats_list_dict).map(p => {
                        return [parallel_xScale(p), parallel_yScale[p](d[p])]
                    }))

                    return result_path
                }
            // console.log(Object.values(dict))
            // console.log(Object.entries({foo: 42, bar: true})) // [{key: "foo", value: 42}, {key: "bar", value: true}]
            parallel_svg.selectAll("myPath")
                .data(Object.values(dict))
                .enter()
                .append("path")
                .attr("d",  path)
                .style("fill", "none")
                .style("stroke", "#69b3a2")
                .style("opacity", 0.5)
        }

        


        ready();
    </script>
</html>