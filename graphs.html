<!DOCTYPE html>
<style>
    body {
        margin: 0;
        display: flex;
        width: 1000px;
        padding: 100px;
    }
    .selections {
        padding-left: 20px;
    }
    strong {
        display: flex;
        width: 130px;
        justify-content: space-between;
    }
</style>
<html>
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- <link rel="stylesheet" href="styles/styles.css"> -->
        <title>Pok√©Stats</title>
    </head>
    <body>
        <div id="graphs"></div>
        <div class="selections">
            <div>
                <strong>x: <select id="stat1" class="dropdown"></select></strong><br>
                <strong>y: <select id="stat2" class="dropdown"></select></strong><br>
            </div>
            <form id="types"></form>
        </div>
        
    </body>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        var dict = {};
        var curr_types = [];
        // let stats_list_dict = { // needed to set the bounds of parallel axes
        //     "HP": [],
        //     "Attack": [],
        //     "Defense": [],
        //     "Sp_Attack": [],
        //     "Sp_Defense": [],
        //     "Speed": []
        // }
        
        async function ready() {
            const data = await d3.csv("/pokedex.csv", function(d) {
                // console.log(d)
                dict[d.name] = {
                    "HP": parseInt(d.hp),
                    "Attack": parseInt(d.attack),
                    "Defense": parseInt(d.defense),
                    "Sp_Attack": parseInt(d.sp_attack),
                    "Sp_Defense": parseInt(d.sp_defense),
                    "Speed": parseInt(d.speed),
                    "types": d.type_number == 2 ? [d.type_1, d.type_2] : [d.type_1],
                    "legendary": d.status
                }
                
                // stats_list_dict['HP'].push(parseInt(d.hp))
                // stats_list_dict['Attack'].push(parseInt(d.attack))
                // stats_list_dict['Defense'].push(parseInt(d.defense))
                // stats_list_dict['Sp_Attack'].push(parseInt(d.sp_attack))
                // stats_list_dict['Sp_Defense'].push(parseInt(d.sp_defense))
                // stats_list_dict['Speed'].push(parseInt(d.speed))

            })
            
            Draw();
            drawLines();
        }


        // Scatter Plot
        var margin = { top: 70, right: 10, bottom: 20, left: 100 };
        var width = 1280 - margin.left - margin.right;
        var height = 750 - margin.top - margin.bottom;

        // Adding new svg for Scatter Plot
        var scatter_svg = d3.select("#graphs").append("svg")
            .style("width", '1280px')
            .style("height", '750')
            .style("outline", '3px solid black')
            .attr("class", "graph")
            .attr("id", "scatter_svg")
            .append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        

        // var dict = {};
        var x_axis = "HP";
        var y_axis = "HP";
        // var curr_types = [];

        var stat_options1 = ["HP", "Attack", "Defense", "Sp_Attack", "Sp_Defense", "Speed"]
        var stat_options2 = ["HP", "Attack", "Defense", "Sp_Attack", "Sp_Defense", "Speed"]
        var type_options = ["Normal", "Fire", "Water", "Grass", "Electric", "Ice", "Fighting", "Poison", "Ground", "Flying", "Psychic", "Bug", "Rock", "Ghost", "Dark", "Dragon", "Steel", "Fairy"]

        d3.select("#stat1")
            .selectAll("myOptions")
                .data(stat_options1)
            .enter().append('option')
            .text(d => d)
            .attr("value", d => d);
        d3.select("#stat2")
            .selectAll("myOptions")
                .data(stat_options2)
            .enter().append('option')
            .text(d => d)
            .attr("value", d => d);

        d3.select("#stat1").on("change", function(d) {
            x_axis = d3.select(this).property("value");
            Draw();
        })
        d3.select("#stat2").on("change", function(d) {
            y_axis = d3.select(this).property("value");
            Draw();
        })

        type_options.forEach((val) => {
            document.querySelector("#types").innerHTML +=`
            <input type="checkbox" id=${val} name=${val} value=${val} class="type" onchange="update()" >
            <label for=${val}>${val}</label><br>`
        })
        
        function update() { // tie both Draw and drawLines together
            Draw();
            drawLines();
        }

        function Draw() {
            //var filtered_dict = dict.filter(key => curr_types.includes(dict[key].types[0]) || (dict[key].types.length == 2 ? curr_types.includes(dict[key].types[1]) : false))
            curr_types = []
            document.querySelectorAll(".type").forEach((val) => {
                if (val.checked) {
                    curr_types.push(val.value)
                }
            })
            // if (curr_types.length==0) {
            //     curr_types = type_options
            // }
            var filtered_dict = Object.keys(dict).reduce(function (filtered_dict, key) {
                if (curr_types.includes(dict[key].types[0]) || (dict[key].types.length == 2 ? curr_types.includes(dict[key].types[1]) : false)) {
                // if (curr_types.includes(dict[key].types[0])) {
                    filtered_dict[key] = {
                        "x": dict[key][x_axis],
                        "y": dict[key][y_axis],
                        "types": dict[key]["types"],
                        "legendary": dict[key]["legendary"]
                    };
                }
                return filtered_dict
            }, {})
            console.log(filtered_dict)
            var xScale = d3.scaleLinear()
                .domain(d3.extent(Object.keys(filtered_dict), key => filtered_dict[key].x))
                .range([0, 1000]);
            var yScale = d3.scaleLinear()
                .domain(d3.extent(Object.keys(filtered_dict), key => filtered_dict[key].y))
                .range([600, 0]);
            
            var xAxis = d3.axisBottom()
                .scale(xScale);
            var yAxis = d3.axisLeft()
                .scale(yScale);
            if (scatter_svg.selectAll("#xaxis").size() == 0){
                scatter_svg.append("g")
                    .call(xAxis)
                    .attr("transform", "translate(0, 600)")
                    .attr("id", "xaxis");
                scatter_svg.append("g")
                    .call(yAxis)
                    .attr("id", "yaxis");

                scatter_svg.append("text")
                    .attr("text-anchor", "middle")
                    .attr("x", (width - margin.left - margin.right) / 2)
                    .attr("y", height)
                    .attr("font-size", 30)
                    .attr("id", "xtext")
                    .text(x_axis)  
                
                scatter_svg.append("text")
                    .attr("text-anchor", "middle")
                    .attr("x", -(height - margin.top - margin.bottom) / 2)
                    .attr("y", -50)
                    .attr("font-size", 30)
                    .attr("id", "ytext")
                    .attr("transform", "rotate(-90)")
                    .text(y_axis)
            } else {
                scatter_svg.select("#xaxis")
                    .transition()
                        .duration(300)
                        .call(xAxis);
                scatter_svg.select("#yaxis")
                    .transition()
                        .duration(300)
                        .call(yAxis);
                scatter_svg.select("#xtext")
                    .text(x_axis)
                scatter_svg.select("#ytext")
                    .text(y_axis)
            }
            scatter_svg.append("text")
                .attr("id", "title")
                .attr("text-anchor", "middle")
                .attr("x", (width - margin.left - margin.right) / 2)
                .attr("y", -margin.top/3)
                .attr("font-size", 40)
                .text(`${x_axis}vs ${y_axis}`)               // GOT TITLE TO UPDATE!!!
                // .text("Attack vs Sp Attack")

            let scatter_title = scatter_svg.selectAll("#title")
                
            scatter_title.enter().append("text")
                .attr("text-anchor", "middle")
                .attr("x", (width - margin.left - margin.right) / 2)
                .attr("y", -margin.top/3)
                .attr("font-size", 40)
                .text(`${x_axis} vs ${y_axis}`)
            scatter_title.transition()
                .duration(500)
                .attr("text-anchor", "middle")
                .attr("x", (width - margin.left - margin.right) / 2)
                .attr("y", -margin.top/3)
                .attr("font-size", 40)
                .text(`${x_axis} vs ${y_axis}`)

            var selection = scatter_svg.selectAll("circle")
                .data(Object.keys(filtered_dict))
                                
            selection.enter().append("circle")
                .attr("cx", key => xScale(filtered_dict[key].x))
                .attr("cy", key => yScale(filtered_dict[key].y))
                .attr("r", 5)
                .attr("fill", key => getColor(filtered_dict[key].types[0]))
                .on('mouseover', key => console.log(key))

            // Jacob: from my understanding, selection.transition() is equivalent to selection.join(update)
            selection.transition()
                .duration(500)
                .attr("cx", key => xScale(filtered_dict[key].x))
                .attr("cy", key => yScale(filtered_dict[key].y))
                .attr("r", 5)
                .attr("fill", key => getColor(filtered_dict[key].types[0]))
                
                
            selection.exit().remove()
        }

        function getColor(type) {
            switch (type) {
                case "Normal": 
                    return "#A8A77A";
                case "Fire": 
                    return "#EE8130";
                case "Water": 
                    return "#6390F0";
                case "Electric": 
                    return "#F7D02C";
                case "Grass": 
                    return "#7AC74C";
                case "Ice": 
                    return "#96D9D6";
                case "Fighting": 
                    return "#C22E28";
                case "Poison": 
                    return "#A33EA1";
                case "Ground": 
                    return "#E2BF65";
                case "Flying": 
                    return "#A98FF3";
                case "Psychic": 
                    return "#F95587";
                case "Bug": 
                    return "#A6B91A";
                case "Rock": 
                    return "#B6A136";
                case "Ghost": 
                    return "#735797";
                case "Dragon": 
                    return "#6F35FC";
                case "Dark": 
                    return "#705746";
                case "Steel": 
                    return "#B7B7CE";
                case "Fairy": 
                    return "#D685AD";
                default:
                    console.log("something wrong with types")
            }
        }


        // Adding new svg for Parallel Coordinates
        var parallel_svg = d3.select("#graphs").append("svg")
            .style("width", '1280px')
            .style("height", '750')
            .style("outline", '3px solid black')
            .attr("class", "graph")
            .attr("id", "parallel_svg")
            .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        function drawLines() {
            // use the same curr_types list to reference selected types
            var filtered_dict = Object.keys(dict).reduce(function (filtered_dict, key) {
                if (curr_types.includes(dict[key].types[0]) || (dict[key].types.length == 2 ? curr_types.includes(dict[key].types[1]) : false)) {
                // if (curr_types.includes(dict[key].types[0])) {
                    filtered_dict[key] = {
                        "HP": dict[key]['HP'],
                        "Attack": dict[key]['Attack'],
                        "Defense": dict[key]['Defense'],
                        "Sp_Attack": dict[key]['Sp_Attack'],
                        "Sp_Defense": dict[key]['Sp_Defense'],
                        "Speed": dict[key]['Speed'],
                        "types": dict[key]["types"]
                    };
                }
                return filtered_dict
            }, {})

            // Find bounds of each stat over pokemon of selected types
            
            // let filtered_stats_extents = { // Unneccessary
            //     "HP": [],
            //     "Attack": [],
            //     "Defense": [],
            //     "Sp_Attack": [],
            //     "Sp_Defense": [],
            //     "Speed": []
            // }
            // for (let i in filtered_dict) {
            //     filtered_stats_extents['HP'].push(filtered_dict[i]['HP'])
            //     filtered_stats_extents['Attack'].push(filtered_dict[i]['Attack'])
            //     filtered_stats_extents['Defense'].push(filtered_dict[i]['Defense'])
            //     filtered_stats_extents['Sp_Attack'].push(filtered_dict[i]['Sp_Attack'])
            //     filtered_stats_extents['Sp_Defense'].push(filtered_dict[i]['Sp_Defense'])
            //     filtered_stats_extents['Speed'].push(filtered_dict[i]['Speed'])
            // }
            

            // Initializing Axes Scales for Parallel Coordinates
            let parallel_yScale = {}
            for(let i in stat_options1) {
                stat_name = stat_options1[i]
                parallel_yScale[stat_name] = d3.scaleLinear()
                    // .domain(d3.extent(filtered_stats_extents[stat_name]))
                    .domain(d3.extent(Object.keys(filtered_dict), key => filtered_dict[key][stat_name]))
                    .range([height, 0])
            }
            let parallel_xScale = d3.scalePoint()
                .domain(stat_options1)    
                .range([0, width-margin.left])


            // Adding parallel axes // either works!
            let parallel_yAxes = parallel_svg.selectAll(".parallel_yAxis")
                .data(stat_options1)
            
            parallel_yAxes.enter().append("g")
                .attr("class", "parallel_yAxis")
                .attr("transform", function(d) { return "translate(" + parallel_xScale(d) + ")"; })
                .each(function(d) { d3.select(this).call(d3.axisLeft().scale(parallel_yScale[d])) })
                .append("text")
                    .style("text-anchor", "middle")
                    .attr("y", -margin.top/2)
                    .text(function(d) { return d; })
                    .style("fill", "black")
                    .attr("font-size", 25)
            parallel_yAxes.transition()
                .duration(500)
                .each(function(d) { d3.select(this).call(d3.axisLeft().scale(parallel_yScale[d])) })

            parallel_yAxes.exit().remove()
            
            // Adding parallel axes // either works!
            // if (parallel_svg.selectAll(".parallel_yAxis").size() == 0){
            //     parallel_svg.selectAll(".parallel_yAxis")
            //         .data(stat_options1)
            //         .enter()
            //         .append("g")
            //         .attr("class", "parallel_yAxis")
            //         .attr("transform", function(d) { return "translate(" + parallel_xScale(d) + ")"; })
            //         .each(function(d) { d3.select(this).call(d3.axisLeft().scale(parallel_yScale[d])) })
            //         .append("text")
            //             .style("text-anchor", "middle")
            //             .attr("y", -margin.top/2)
            //             .text(function(d) { return d; })
            //             .style("fill", "black")
            //             .attr("font-size", 25)
            // } else {
            //     parallel_svg.selectAll(".parallel_yAxis")
            //         .transition()
            //             .duration(300)
            //             .each(function(d) { d3.select(this).call(d3.axisLeft().scale(parallel_yScale[d])) })
            // }
            
            function path(d) { // helper function to produce coordinates for path of line (receives filtered_dict keys as input)
                const result_path = d3.line()(stat_options1.map(p => {
                    // return [parallel_xScale(p), parallel_yScale[p](d[p])]
                    return [parallel_xScale(p), parallel_yScale[p](filtered_dict[d][p])]
                }))
                // console.log(result_path)
                return result_path
            }
            // console.log(Object.values(dict))
            // parallel_svg.selectAll("path")
            //     .data(Object.values(filtered_dict))
            //     .enter()
            //     .append("path")
            //     .attr("class", "path")
            //     .attr("d",  path)
            //     .style("fill", "none")
            //     .style("stroke", "#69b3a2")
            //     .style("opacity", 0.5)


            // Initializing lines
            let all_paths = parallel_svg.selectAll(".line")
                .data(Object.keys(filtered_dict))
                                
            all_paths.enter().append("path")
                .attr("d",  path)
                .attr("class", "line")
                .style("fill", "none")
                .style("stroke", key => getColor(filtered_dict[key].types[0]))
                .on('mouseover', key => console.log(key))

            all_paths.transition()
                .duration(500)
                .style("fill", "none")
                .style("stroke", key => getColor(filtered_dict[key].types[0]))
                .attr("d",  path)
                
            all_paths.exit().remove()
        }

        


        ready();
    </script>
</html>